/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => HugoExportPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var fs = __toESM(require("fs"));
var path = __toESM(require("path"));
var DEFAULT_SETTINGS = {
  hugoExportPath: "",
  defaultAuthor: ""
};
var HugoExportPlugin = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addCommand({
      id: "export-to-hugo",
      name: "Export current note to Hugo",
      checkCallback: (checking) => {
        const file = this.app.workspace.getActiveFile();
        if (file) {
          if (!checking) {
            this.exportToHugo(file);
          }
          return true;
        }
        return false;
      }
    });
    this.addSettingTab(new HugoExportSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async exportToHugo(file) {
    if (!this.settings.hugoExportPath) {
      new import_obsidian.Notice("Please set the Hugo export path in settings first");
      return;
    }
    try {
      const content = await this.app.vault.read(file);
      const hugoContent = this.convertToHugo(content, file);
      const filename = this.generateHugoFilename(file);
      const exportPath = path.join(this.settings.hugoExportPath, filename);
      const dir = path.dirname(exportPath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }
      fs.writeFileSync(exportPath, hugoContent, "utf-8");
      new import_obsidian.Notice(`Exported to: ${exportPath}`);
    } catch (error) {
      console.error("Export failed:", error);
      new import_obsidian.Notice(`Export failed: ${error.message}`);
    }
  }
  convertToHugo(content, file) {
    const frontmatterRegex = /^---\n([\s\S]*?)\n---\n/;
    const match = content.match(frontmatterRegex);
    let body = content;
    let existingFrontmatter = {};
    if (match) {
      body = content.slice(match[0].length);
      const lines = match[1].split("\n");
      for (const line of lines) {
        const colonIndex = line.indexOf(":");
        if (colonIndex > 0) {
          const key = line.slice(0, colonIndex).trim();
          const value = line.slice(colonIndex + 1).trim();
          existingFrontmatter[key] = value;
        }
      }
    }
    const date = existingFrontmatter.date || (/* @__PURE__ */ new Date()).toISOString();
    const title = existingFrontmatter.title || file.basename;
    const author = existingFrontmatter.author || this.settings.defaultAuthor || "Unknown";
    const hugoFrontmatter = `---
title: "${title}"
date: ${date}
author: ${author}
draft: false
---

`;
    return hugoFrontmatter + body;
  }
  generateHugoFilename(file) {
    const basename = file.basename;
    const sanitized = basename.replace(/[^a-z0-9-]/gi, "-").toLowerCase();
    return `${sanitized}.md`;
  }
};
var HugoExportSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Hugo export path").setDesc("Path to your Hugo content directory (e.g., /Users/you/blog/content/posts)").addText((text) => text.setPlaceholder("/path/to/hugo/content/posts").setValue(this.plugin.settings.hugoExportPath).onChange(async (value) => {
      this.plugin.settings.hugoExportPath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default author").setDesc("Your name to use in the author field").addText((text) => text.setPlaceholder("Your Name").setValue(this.plugin.settings.defaultAuthor).onChange(async (value) => {
      this.plugin.settings.defaultAuthor = value;
      await this.plugin.saveSettings();
    }));
  }
};
